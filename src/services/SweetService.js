/**
 * Sweet Service
 * Contains business logic for sweet shop operations
 */

const SweetRepository = require('../repositories/SweetRepository');
const Sweet = require('../models/Sweet');

class SweetService {
  /**
   * Create a new SweetService
   * @param {SweetRepository} repository - Repository instance (optional, for testing)
   */
  constructor(repository = null) {
    this.repository = repository || new SweetRepository();
  }

  /**
   * Get all sweets
   * @returns {Promise<Sweet[]>} Array of all sweets
   */
  async getAllSweets() {
    return await this.repository.findAll();
  }

  /**
   * Get a sweet by ID
   * @param {number} id - Sweet ID
   * @returns {Promise<Sweet>} Sweet instance
   * @throws {Error} If sweet not found
   */
  async getSweetById(id) {
    const sweet = await this.repository.findById(id);
    
    if (!sweet) {
      throw new Error(`Sweet with ID ${id} not found`);
    }
    
    return sweet;
  }

  /**
   * Add a new sweet to the shop
   * @param {Object} sweetData - Sweet data
   * @returns {Promise<Sweet>} Created sweet instance
   * @throws {Error} If validation fails
   */
  async addSweet(sweetData) {
    // Validate data by creating a Sweet instance
    // This will throw an error if validation fails
    new Sweet({ id: 0, ...sweetData }); // id is temporary, will be generated by DB
    
    return await this.repository.create(sweetData);
  }

  /**
   * Update an existing sweet
   * @param {number} id - Sweet ID
   * @param {Object} updateData - Updated sweet data
   * @returns {Promise<Sweet>} Updated sweet instance
   * @throws {Error} If sweet not found or validation fails
   */
  async updateSweet(id, updateData) {
    // First check if sweet exists
    const existingSweet = await this.repository.findById(id);
    
    if (!existingSweet) {
      throw new Error(`Sweet with ID ${id} not found`);
    }
    
    // Validate data
    new Sweet({ id, ...updateData });
    
    const sweet = await this.repository.update(id, updateData);
    
    return sweet;
  }

  /**
   * Delete a sweet from the shop
   * @param {number} id - Sweet ID
   * @returns {Promise<boolean>} True if deleted successfully
   * @throws {Error} If sweet not found
   */
  async deleteSweet(id) {
    const deleted = await this.repository.delete(id);
    
    if (!deleted) {
      throw new Error(`Sweet with ID ${id} not found`);
    }
    
    return true;
  }

  /**
   * Search sweets by category
   * @param {string} category - Category name
   * @returns {Promise<Sweet[]>} Array of sweets in category
   */
  async searchByCategory(category) {
    return await this.repository.findByCategory(category);
  }

  /**
   * Search sweets by name
   * @param {string} name - Name to search for
   * @returns {Promise<Sweet[]>} Array of matching sweets
   */
  async searchByName(name) {
    return await this.repository.findByName(name);
  }

  /**
   * Search sweets by price range
   * @param {number} minPrice - Minimum price
   * @param {number} maxPrice - Maximum price
   * @returns {Promise<Sweet[]>} Array of sweets in price range
   * @throws {Error} If price range is invalid
   */
  async searchByPriceRange(minPrice, maxPrice) {
    // Validate price range
    if (minPrice < 0 || maxPrice < 0) {
      throw new Error('Prices must be positive numbers');
    }
    
    if (minPrice > maxPrice) {
      throw new Error('Minimum price cannot be greater than maximum price');
    }
    
    return await this.repository.findByPriceRange(minPrice, maxPrice);
  }

  /**
   * Purchase sweets (decrease quantity)
   * @param {number} id - Sweet ID
   * @param {number} quantity - Quantity to purchase
   * @returns {Promise<Sweet>} Updated sweet instance
   * @throws {Error} If insufficient stock or sweet not found
   */
  async purchaseSweet(id, quantity) {
    // Validate purchase quantity
    if (quantity <= 0) {
      throw new Error('Purchase quantity must be greater than zero');
    }
    
    // Get current sweet
    const sweet = await this.repository.findById(id);
    
    if (!sweet) {
      throw new Error(`Sweet with ID ${id} not found`);
    }
    
    // Check if enough stock available
    if (sweet.quantity < quantity) {
      throw new Error(`Insufficient stock. Available: ${sweet.quantity}, Requested: ${quantity}`);
    }
    
    // Calculate new quantity
    const newQuantity = sweet.quantity - quantity;
    
    // Update quantity in database
    return await this.repository.updateQuantity(id, newQuantity);
  }

  /**
   * Restock sweets (increase quantity)
   * @param {number} id - Sweet ID
   * @param {number} quantity - Quantity to add
   * @returns {Promise<Sweet>} Updated sweet instance
   * @throws {Error} If sweet not found or quantity invalid
   */
  async restockSweet(id, quantity) {
    // Validate restock quantity
    if (quantity <= 0) {
      throw new Error('Restock quantity must be greater than zero');
    }
    
    // Get current sweet
    const sweet = await this.repository.findById(id);
    
    if (!sweet) {
      throw new Error(`Sweet with ID ${id} not found`);
    }
    
    // Calculate new quantity
    const newQuantity = sweet.quantity + quantity;
    
    // Update quantity in database
    return await this.repository.updateQuantity(id, newQuantity);
  }

  /**
   * Check if a sweet is in stock
   * @param {number} id - Sweet ID
   * @returns {Promise<boolean>} True if in stock (quantity > 0)
   * @throws {Error} If sweet not found
   */
  async checkStock(id) {
    const sweet = await this.repository.findById(id);
    
    if (!sweet) {
      throw new Error(`Sweet with ID ${id} not found`);
    }
    
    return sweet.quantity > 0;
  }
}

module.exports = SweetService;
